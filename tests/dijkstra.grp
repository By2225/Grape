fun Int dist(Graph<Int, Int> g, Node<Int> source, Node<Int> dest){
    List<Edge<Int> > outgo = g.outgoing(source);
    Int i = 0;
    while( i < size(outgo)){
        if(node_same(outgo[i].to, dest)){
            return outgo[i].val;
        }
        i = i+1;
    }
    return -1;
} 
fun List<Node<Int> > dijkstra( Graph<Int, Int> iter_graph, Node<Int> start_node, Node<Int> end_node){
	
        print("here3");
	List<Node<Int> > visited;
	List<Node<Int> > result;
	List<Node<Int> > nodeList;
	List<Node<Int> > previous_record; 
	List<Node<Int> > neighbor_list;
	Node<Int> next_node;
	Int i;
	Int j;
	Int x;
	Int temp;
	Int distance;

	nodeList = graph_to_list(iter_graph);
        print(nodeList[0].val);
        print("g_t_l work");
	Node<Int> current_node = start_node;
	Int graph_size = size(nodeList);
        print("graph_size work");
	Int count = 0;
        print("here4");

	//initializing previous_record with current node
	while(count < graph_size){
		previous_record = update_at(current_node , previous_record, count);  	
		count = count + 1;
	}

	//run until all nodes are visited

	while(size(visited) != graph_size){ 
		neighbor_list = neighbor(current_node);
		i = size(neighbor_list);
		j = 0; 

		//iter through neighbor list updating node value
		while (j < i){
			next_node = neighbor_list[j];
			distance = dist(iter_graph, current_node, next_node) + get_val(current_node);
			
			//update previous record and distance 			
			if (get_val(next_node) > distance){
				//TODO
				next_node = update_node(next_node, distance);

				x = 0;

				//update previous record 
				while(x < size(nodeList)){
					if(node_same(nodeList[x] ,next_node)){
						previous_record = update_at(current_node, previous_record, x);
					}
					x = x+1;
				}
			} 
			j = j+1;
		}

		//add_to visited and change current node
		push_front_list_node(visited, current_node);
		current_node = minNode(visited, iter_graph);
	}

	Node<Int> follow = end_node; 
	while( not(node_same(follow, start_node))){
		push_front_list_node(result, follow);
		temp = 0;
		while (temp < graph_size){
			if(node_same(nodeList[temp], follow)){
				follow = previous_record[temp];
				}
			temp = temp + 1;
			}
		}	

	push_front_list_node(result, start_node);
	return result;
}

fun Node<Int> minNode(List<Node<Int> > visited, List<Node<Int> > nodeList){

	Node<Int> target; 
        print("here 2");

	Int min = 10000;
	Int j = 0;
	Int k;
	Int present;
	while ( j < size(nodeList) ){

			k = 0;
			present = 0; 
			
			while(k < size(visited)){
				
				if(node_same(visited[k], nodeList[j])){
				    present = 1;
				}
 
				k = k + 1; 
			}
		//TODO*****
		if (get_val(nodeList[j]) < min and present == 0){
			target = nodeList[j];
			min = get_val(nodeList[j]);
		}

		j = j + 1; 
	}

    return target; 
}

fun Int main(){

    Node<Int> a = '0';
    Node<Int> b = '10000';
    Node<Int> c = '10000';
    Node<Int> d = '10000';
    Node<Int> e = '10000';
    Node<Int> f = '10000';
    Node<Int> g = '10000';

    Graph<Int, Int> mainGraph = << a -2- b -5- d -3- g , 
			       a -3- c -7- e -4- f -2- g,
			       d -2- f >>; 

    print("here1");
    List<Node<Int> > result = graph_to_list(mainGraph);

    result = dijkstra(mainGraph, a, g);
        //don't know how to print a list of nodes
    return 0;
}


