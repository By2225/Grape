
fun Int main() {
Node<Int> (Node<Int> : a = (Node<Int> : '(Int : 0)'));
Node<Int> (Node<Int> : b = (Node<Int> : '(Int : 10000)'));
Node<Int> (Node<Int> : c = (Node<Int> : '(Int : 10000)'));
Node<Int> (Node<Int> : d = (Node<Int> : '(Int : 10000)'));
Node<Int> (Node<Int> : e = (Node<Int> : '(Int : 10000)'));
Node<Int> (Node<Int> : f = (Node<Int> : '(Int : 10000)'));
Node<Int> (Node<Int> : g = (Node<Int> : '(Int : 10000)'));
List<Node<Int>> (List<Node<Int>> : nodes = (List<Node<Int>> : [(Node<Int> : a),(Node<Int> : b),(Node<Int> : c),(Node<Int> : d),(Node<Int> : e),(Node<Int> : f),(Node<Int> : g)]));
Graph<Node<Int>, Edge<Int->Int>> (Graph<Node<Int>, Edge<Int->Int>> : mainGraph = (Graph<Node<Int>, Edge<Int->*>> : <(Node<Int> : a) (Edge<Int->*> : -(Int : 2)-) (Node<Int> : b) (Edge<Int->*> : -(Int : 5)-) (Node<Int> : d) (Edge<Int->*> : -(Int : 3)-) (Node<Int> : g) (Void : ), (Node<Int> : a) (Edge<Int->*> : -(Int : 3)-) (Node<Int> : c) (Edge<Int->*> : -(Int : 7)-) (Node<Int> : e) (Edge<Int->*> : -(Int : 4)-) (Node<Int> : f) (Edge<Int->*> : -(Int : 2)-) (Node<Int> : g) (Void : ), (Node<Int> : d) (Edge<Int->*> : -(Int : 2)-) (Node<Int> : f) (Void : )>));
Graph<Node<Int>, Edge<Int->Int>> (Graph<Node<Int>, Edge<Int->Int>> : mainGraph2 = (Graph<Node<Int>, Edge<Int->*>> : <(Node<Int> : g) (Edge<Int->*> : -(Int : 3)-) (Node<Int> : d) (Edge<Int->*> : -(Int : 5)-) (Node<Int> : b) (Edge<Int->*> : -(Int : 2)-) (Node<Int> : a) (Void : ), (Node<Int> : g) (Edge<Int->*> : -(Int : 2)-) (Node<Int> : f) (Edge<Int->*> : -(Int : 4)-) (Node<Int> : e) (Edge<Int->*> : -(Int : 7)-) (Node<Int> : c) (Edge<Int->*> : -(Int : 3)-) (Node<Int> : a) (Void : ), (Node<Int> : f) (Edge<Int->*> : -(Int : 2)-) (Node<Int> : d) (Void : )>));
List<Node<Int>> result;
(List<Node<Int>> : result = (List<Node<Int>> : dijkstra((Node<Int> : g), (Node<Int> : a), (Graph<Node<Int>, Edge<Int->Int>> : mainGraph))));
(* : print((String : Shortest Path:)));
Int (Int : i = (Int : 0));
Int (Int : j = (Int : 0));
Int (Int : reSz = (Int : size((List<Node<Int>> : result))));
while ((Bool : (Int : i) < (Int : reSz))) {
(Int : j = (Int : 0));
while ((Bool : (Int : j) < (Int : size((List<Node<Int>> : nodes))))) {
if ((Bool : node_same((Node<Int> : (List<Node<Int>> : result)[(Int : i)]), (Node<Int> : (List<Node<Int>> : nodes)[(Int : j)]))))
{
if ((Bool : (Int : j) == (Int : 0)))
{
(* : print((String : A)));
}
if ((Bool : (Int : j) == (Int : 1)))
{
(* : print((String : B)));
}
if ((Bool : (Int : j) == (Int : 2)))
{
(* : print((String : C)));
}
if ((Bool : (Int : j) == (Int : 3)))
{
(* : print((String : D)));
}
if ((Bool : (Int : j) == (Int : 4)))
{
(* : print((String : E)));
}
if ((Bool : (Int : j) == (Int : 5)))
{
(* : print((String : F)));
}
if ((Bool : (Int : j) == (Int : 6)))
{
(* : print((String : G)));
}
(Int : j = (Int : 10000));
}
(Int : j = (Int : (Int : j) + (Int : 1)));
}
(Int : i = (Int : (Int : i) + (Int : 1)));
}
(* : print((String : Total cost)));
(* : print((Int : (Node<Int> : (List<Node<Int>> : result)[(Int : (Int : reSz) - (Int : 1))]).val)));
return (Int : 0);
}

fun Node<Int> minNode(visited, nodeList) {
Node<Int> target;
Int (Int : min = (Int : 10000));
Int (Int : j = (Int : 0));
Int k;
Int present;
Bool (Bool : found = (Bool : false));
while ((Bool : (Int : j) < (Int : size((List<Node<Int>> : nodeList))))) {
(Int : k = (Int : 0));
(Int : present = (Int : 0));
while ((Bool : (Int : k) < (Int : size((List<Node<Int>> : visited))))) {
if ((Bool : node_same((Node<Int> : (List<Node<Int>> : nodeList)[(Int : j)]), (Node<Int> : (List<Node<Int>> : visited)[(Int : k)]))))
{
(Int : present = (Int : 1));
}
(Int : k = (Int : (Int : k) + (Int : 1)));
}
if ((Bool : (Bool : (Int : (Node<Int> : (List<Node<Int>> : nodeList)[(Int : j)]).val) < (Int : min)) and (Bool : (Int : present) == (Int : 0))))
{
(Node<Int> : target = (Node<Int> : (List<Node<Int>> : nodeList)[(Int : j)]));
(Int : min = (Int : (Node<Int> : (List<Node<Int>> : nodeList)[(Int : j)]).val));
(Bool : found = (Bool : true));
}
(Int : j = (Int : (Int : j) + (Int : 1)));
}
if ((Bool : (Bool : found) == (Bool : true)))
{
return (Node<Int> : target);
}
return (Node<Int> : '(Int : 85043210)');
}

fun List<Node<Int>> dijkstra(iter_graph, start_node, end_node) {
List<Node<Int>> (List<Node<Int>> : visited = (List<*> : []));
List<Node<Int>> (List<Node<Int>> : result = (List<*> : []));
List<Node<Int>> nodeList;
List<Node<Int>> (List<Node<Int>> : previous_record = (List<*> : []));
List<Node<Int>> neighbor_list;
Node<Int> next_node;
Node<Int> (Node<Int> : dummy = (Node<Int> : '(Int : 999)'));
Int i;
Int j;
Int x;
Int k;
Int present;
Int visSz;
Int temp;
Int distance;
(List<Node<Int>> : nodeList = (List<Node<Int>> : graph_to_list((Graph<Node<Int>, Edge<Int->Int>> : iter_graph))));
Node<Int> (Node<Int> : current_node = (Node<Int> : start_node));
Int (Int : graph_size = (Int : size((List<Node<Int>> : nodeList))));
Int (Int : count = (Int : 0));
(Void : push_front_list_node((List<Node<Int>> : previous_record), (Node<Int> : start_node)));
while ((Bool : (Int : count) < (Int : (Int : graph_size) - (Int : 1)))) {
(Void : push_front_list_node((List<Node<Int>> : previous_record), (Node<Int> : dummy)));
(Int : count = (Int : (Int : count) + (Int : 1)));
}
while ((Bool : (Bool : (Int : size((List<Node<Int>> : visited))) < (Int : graph_size)) and (Bool : (Int : (Node<Int> : current_node).val) != (Int : 85043210)))) {
(List<Node<Int>> : neighbor_list = (List<Node<Int>> : neighbor((Node<Int> : current_node))));
(Int : i = (Int : size((List<Node<Int>> : neighbor_list))));
(Int : j = (Int : 0));
while ((Bool : (Int : j) < (Int : i))) {
(Int : present = (Int : 0));
(Int : k = (Int : 0));
(Node<Int> : next_node = (Node<Int> : (List<Node<Int>> : neighbor_list)[(Int : j)]));
while ((Bool : (Int : k) < (Int : size((List<Node<Int>> : visited))))) {
if ((Bool : node_same((Node<Int> : next_node), (Node<Int> : (List<Node<Int>> : visited)[(Int : k)]))))
{
(Int : present = (Int : 1));
}
(Int : k = (Int : (Int : k) + (Int : 1)));
}
(Int : distance = (Int : (Int : dist((Node<Int> : next_node), (Node<Int> : current_node), (Graph<Node<Int>, Edge<Int->Int>> : iter_graph))) + (Int : (Node<Int> : current_node).val)));
if ((Bool : (Bool : (Int : (Node<Int> : next_node).val) > (Int : distance)) and (Bool : (Int : present) == (Int : 0))))
{
(Node<Int> : next_node = (Node<Int> : update_node((Int : distance), (Node<Int> : next_node))));
(Int : x = (Int : 0));
while ((Bool : (Int : x) < (Int : size((List<Node<Int>> : nodeList))))) {
if ((Bool : node_same((Node<Int> : next_node), (Node<Int> : (List<Node<Int>> : nodeList)[(Int : x)]))))
{
(List<Node<Int>> : previous_record = (List<Node<Int>> : update_at((Int : x), (List<Node<Int>> : previous_record), (Node<Int> : current_node))));
}
(Int : x = (Int : (Int : x) + (Int : 1)));
}
}
(Int : j = (Int : (Int : j) + (Int : 1)));
}
(Void : push_front_list_node((List<Node<Int>> : visited), (Node<Int> : current_node)));
(Node<Int> : current_node = (Node<Int> : minNode((List<Node<Int>> : nodeList), (List<Node<Int>> : visited))));
}
Node<Int> (Node<Int> : follow = (Node<Int> : end_node));
while ((Bool : not(Bool : node_same((Node<Int> : start_node), (Node<Int> : follow))))) {
(Void : push_front_list_node((List<Node<Int>> : result), (Node<Int> : follow)));
(Int : temp = (Int : 0));
while ((Bool : (Int : temp) < (Int : graph_size))) {
if ((Bool : node_same((Node<Int> : follow), (Node<Int> : (List<Node<Int>> : nodeList)[(Int : temp)]))))
{
(Node<Int> : follow = (Node<Int> : (List<Node<Int>> : previous_record)[(Int : temp)]));
}
(Int : temp = (Int : (Int : temp) + (Int : 1)));
}
}
(Void : push_front_list_node((List<Node<Int>> : result), (Node<Int> : start_node)));
return (List<Node<Int>> : result);
}

fun Int dist(g, source, dest) {
List<Edge<Int->*>> (List<Edge<Int->Int>> : outgo = (List<Edge<Int->Int>> : (Graph<Node<Int>, Edge<Int->Int>> : g)outgoing((Node<Int> : source))));
Int (Int : i = (Int : 0));
while ((Bool : (Int : i) < (Int : size((List<Edge<Int->*>> : outgo))))) {
if ((Bool : node_same((Node<Int> : dest), (Node<*> : (Edge<Int->*> : (List<Edge<Int->*>> : outgo)[(Int : i)]).to))))
{
return (Int : (Edge<Int->*> : (List<Edge<Int->*>> : outgo)[(Int : i)]).val);
}
(Int : i = (Int : (Int : i) + (Int : 1)));
}
return (Int : 100000);
}
